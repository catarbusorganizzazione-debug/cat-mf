var getItemReverseCyclic = function getItemReverseCyclic(index, array) {
  var id = (array.length - index % array.length - 1 + array.length) % array.length;
  return array[id];
};

var getItemPalindrome = function getItemPalindrome(index, array) {
  var arraySize = array.length;

  if (arraySize === 1) {
    return array[0];
  }

  var id = index % (2 * arraySize - 2);

  if (id < arraySize) {
    return array[id];
  } else {
    return array[2 * arraySize - id - 2];
  }
};

var getItemCyclic = function getItemCyclic(index, array) {
  var id = index % array.length;
  return array[id];
};

var offset = function offset(list, amount) {
  return [].concat(list.slice(amount), list.slice(0, amount));
};

var patternChunks = function patternChunks(array, pattern) {
  var result = [];

  var _array = [].concat(array);

  var i = 0;

  while (_array.length > 0) {
    result.push(_array.splice(0, getItemCyclic(i, pattern)));
    i++;
  }

  return result;
};

var mapAt = function mapAt(array, index, mapFn) {
  if (index > array.length || index < 0) {
    throw new Error('Index out of range');
  }

  var item = array[index];
  var newItem = mapFn(item); // don't map if item is same

  if (newItem === item) {
    return array;
  }

  var newArray = array.slice();
  newArray[index] = mapFn(array[index]);
  return newArray;
};

var times = function times(iterations, callback) {
  var result = [];

  for (var i = 0; i < iterations; i++) {
    result.push(callback(i));
  }

  return result;
};

export { getItemCyclic, getItemPalindrome, getItemReverseCyclic, mapAt, offset, patternChunks, times };
//# sourceMappingURL=data-fns.esm.js.map
